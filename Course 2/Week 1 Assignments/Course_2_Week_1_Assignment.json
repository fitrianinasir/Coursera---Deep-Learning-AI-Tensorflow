{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "dn-6c02VmqiN"
   },
   "outputs": [],
   "source": [
    "# ATTENTION: Please do not alter any of the provided code in the exercise. Only add your own code where indicated\n",
    "# ATTENTION: Please do not add or remove any cells in the exercise. The grader will check specific cells based on the cell position.\n",
    "# ATTENTION: Please use the provided epoch values when training.\n",
    "\n",
    "# In this exercise you will train a CNN on the FULL Cats-v-dogs dataset\n",
    "# This will require you doing a lot of data preprocessing because\n",
    "# the dataset isn't split into training and validation for you\n",
    "# This code block has all the required inputs\n",
    "import os\n",
    "import zipfile\n",
    "import random\n",
    "import tensorflow as tf\n",
    "import shutil\n",
    "from tensorflow.keras.optimizers import RMSprop\n",
    "from tensorflow.keras.preprocessing.image import ImageDataGenerator\n",
    "from shutil import copyfile\n",
    "from os import getcwd"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "3sd9dQWa23aj"
   },
   "outputs": [],
   "source": [
    "path_cats_and_dogs = f\"{getcwd()}/../tmp2/cats-and-dogs.zip\"\n",
    "shutil.rmtree('/tmp')\n",
    "\n",
    "local_zip = path_cats_and_dogs\n",
    "zip_ref = zipfile.ZipFile(local_zip, 'r')\n",
    "zip_ref.extractall('/tmp')\n",
    "zip_ref.close()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "gi3yD62a6X3S"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1500\n",
      "1500\n"
     ]
    }
   ],
   "source": [
    "print(len(os.listdir('/tmp/PetImages/Cat/')))\n",
    "print(len(os.listdir('/tmp/PetImages/Dog/')))\n",
    "\n",
    "# Expected Output:\n",
    "# 1500\n",
    "# 1500"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "F-QkLjxpmyK2"
   },
   "outputs": [],
   "source": [
    "# Use os.mkdir to create your directories\n",
    "# You will need a directory for cats-v-dogs, and subdirectories for training\n",
    "# and testing. These in turn will need subdirectories for 'cats' and 'dogs'\n",
    "try:\n",
    "    os.mkdir('/tmp/cats-v-dogs')\n",
    "    os.mkdir('/tmp/cats-v-dogs/training')\n",
    "    os.mkdir('/tmp/cats-v-dogs/testing')\n",
    "    os.mkdir('/tmp/cats-v-dogs/training/cats')\n",
    "    os.mkdir('/tmp/cats-v-dogs/training/dogs')\n",
    "    os.mkdir('/tmp/cats-v-dogs/testing/cats')\n",
    "    os.mkdir('/tmp/cats-v-dogs/testing/dogs')\n",
    "    \n",
    "except OSError as e:\n",
    "    print(e)\n",
    "    pass\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "zvSODo0f9LaU"
   },
   "outputs": [],
   "source": [
    "# Write a python function called split_data which takes\n",
    "# a SOURCE directory containing the files\n",
    "# a TRAINING directory that a portion of the files will be copied to\n",
    "# a TESTING directory that a portion of the files will be copie to\n",
    "# a SPLIT SIZE to determine the portion\n",
    "# The files should also be randomized, so that the training set is a random\n",
    "# X% of the files, and the test set is the remaining files\n",
    "# SO, for example, if SOURCE is PetImages/Cat, and SPLIT SIZE is .9\n",
    "# Then 90% of the images in PetImages/Cat will be copied to the TRAINING dir\n",
    "# and 10% of the images will be copied to the TESTING dir\n",
    "# Also -- All images should be checked, and if they have a zero file length,\n",
    "# they will not be copied over\n",
    "#\n",
    "# os.listdir(DIRECTORY) gives you a listing of the contents of that directory\n",
    "# os.path.getsize(PATH) gives you the size of the file\n",
    "# copyfile(source, destination) copies a file from source to destination\n",
    "# random.sample(list, len(list)) shuffles a list\n",
    "def split_data(SOURCE, TRAINING, TESTING, SPLIT_SIZE):\n",
    "    \n",
    "    # YOUR CODE STARTS HERE\n",
    "    \n",
    "    dataset = []\n",
    "    \n",
    "    for file in os.listdir(SOURCE):\n",
    "        data = SOURCE + file\n",
    "        if(os.path.getsize(data) > 0):\n",
    "            dataset.append(file)\n",
    "        else:\n",
    "            pass\n",
    "    \n",
    "    training_length = int(len(dataset) * SPLIT_SIZE)\n",
    "    testing_length = int(len(dataset) - training_length)\n",
    "    shuffled_set = random.sample(dataset, len(dataset))\n",
    "    training_data = dataset[0:training_length]\n",
    "    testing_data = dataset[-testing_length:]\n",
    "       \n",
    "    for file in training_data:\n",
    "        src = SOURCE + file\n",
    "        dest = TRAINING + file\n",
    "        copyfile(src, dest)\n",
    "    \n",
    "    for file in testing_data:\n",
    "        src = SOURCE + file\n",
    "        dest = TESTING + file\n",
    "        copyfile(src, dest)\n",
    "        \n",
    "    # YOUR CODE ENDS HERE\n",
    "\n",
    "CAT_SOURCE_DIR = \"/tmp/PetImages/Cat/\"\n",
    "TRAINING_CATS_DIR = \"/tmp/cats-v-dogs/training/cats/\"\n",
    "TESTING_CATS_DIR = \"/tmp/cats-v-dogs/testing/cats/\"\n",
    "DOG_SOURCE_DIR = \"/tmp/PetImages/Dog/\"\n",
    "TRAINING_DOGS_DIR = \"/tmp/cats-v-dogs/training/dogs/\"\n",
    "TESTING_DOGS_DIR = \"/tmp/cats-v-dogs/testing/dogs/\"\n",
    "\n",
    "split_size = .9\n",
    "split_data(CAT_SOURCE_DIR, TRAINING_CATS_DIR, TESTING_CATS_DIR, split_size)\n",
    "split_data(DOG_SOURCE_DIR, TRAINING_DOGS_DIR, TESTING_DOGS_DIR, split_size)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "luthalB76ufC"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1350\n",
      "1350\n",
      "150\n",
      "150\n"
     ]
    }
   ],
   "source": [
    "print(len(os.listdir('/tmp/cats-v-dogs/training/cats/')))\n",
    "print(len(os.listdir('/tmp/cats-v-dogs/training/dogs/')))\n",
    "print(len(os.listdir('/tmp/cats-v-dogs/testing/cats/')))\n",
    "print(len(os.listdir('/tmp/cats-v-dogs/testing/dogs/')))\n",
    "\n",
    "# Expected output:\n",
    "# 1350\n",
    "# 1350\n",
    "# 150\n",
    "# 150"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "-BQrav4anTmj"
   },
   "outputs": [],
   "source": [
    "# DEFINE A KERAS MODEL TO CLASSIFY CATS V DOGS\n",
    "# USE AT LEAST 3 CONVOLUTION LAYERS\n",
    "model = tf.keras.models.Sequential([\n",
    "    tf.keras.layers.Conv2D(16, (3,3), activation='relu', input_shape=(150, 150, 3)),\n",
    "    tf.keras.layers.MaxPooling2D(2,2),\n",
    "    tf.keras.layers.Conv2D(32, (3,3), activation='relu'),\n",
    "    tf.keras.layers.MaxPooling2D(2,2), \n",
    "    tf.keras.layers.Conv2D(64, (3,3), activation='relu'), \n",
    "    tf.keras.layers.MaxPooling2D(2,2),\n",
    "    tf.keras.layers.Conv2D(64, (3,3), activation='relu'), \n",
    "    tf.keras.layers.MaxPooling2D(2,2),\n",
    "    # Flatten the results to feed into a DNN\n",
    "    tf.keras.layers.Flatten(), \n",
    "    # 512 neuron hidden layer\n",
    "    tf.keras.layers.Dense(512, activation='relu'), \n",
    "    # Only 1 output neuron. It will contain a value from 0-1 where 0 for 1 class ('cats') and 1 for the other ('dogs')\n",
    "    tf.keras.layers.Dense(1, activation='sigmoid')  \n",
    "])\n",
    "\n",
    "model.compile(optimizer=RMSprop(lr=0.001), loss='binary_crossentropy', metrics=['acc'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# NOTE:\n",
    "\n",
    "In the cell below you **MUST** use a batch size of 10 (`batch_size=10`) for the `train_generator` and the `validation_generator`. Using a batch size greater than 10 will exceed memory limits on the Coursera platform."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "mlNjoJ5D61N6"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Found 2700 images belonging to 2 classes.\n",
      "Found 300 images belonging to 2 classes.\n"
     ]
    }
   ],
   "source": [
    "TRAINING_DIR = \"/tmp/cats-v-dogs/training\"\n",
    "train_datagen = ImageDataGenerator(rescale = 1.0/255)\n",
    "\n",
    "# NOTE: YOU MUST USE A BATCH SIZE OF 10 (batch_size=10) FOR THE \n",
    "# TRAIN GENERATOR.\n",
    "train_generator = train_datagen.flow_from_directory(TRAINING_DIR,\n",
    "                                                    batch_size=10,\n",
    "                                                    class_mode='binary',\n",
    "                                                    target_size=(150, 150))\n",
    "\n",
    "VALIDATION_DIR = \"/tmp/cats-v-dogs/testing\"\n",
    "validation_datagen = ImageDataGenerator( rescale = 1.0/255. )\n",
    "\n",
    "# NOTE: YOU MUST USE A BACTH SIZE OF 10 (batch_size=10) FOR THE \n",
    "# VALIDATION GENERATOR.\n",
    "validation_generator = validation_datagen.flow_from_directory(VALIDATION_DIR,\n",
    "                                                             batch_size=10,\n",
    "                                                             class_mode  = 'binary',\n",
    "                                                             target_size = (150, 150))\n",
    "\n",
    "\n",
    "\n",
    "# Expected Output:\n",
    "# Found 2700 images belonging to 2 classes.\n",
    "# Found 300 images belonging to 2 classes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "KyS4n53w7DxC"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 1/2\n",
      "270/270 [==============================] - 55s 204ms/step - loss: 0.6601 - acc: 0.6300 - val_loss: 0.6352 - val_acc: 0.6533\n",
      "Epoch 2/2\n",
      "270/270 [==============================] - 53s 197ms/step - loss: 0.6469 - acc: 0.6300 - val_loss: 0.5464 - val_acc: 0.7400\n"
     ]
    }
   ],
   "source": [
    "history = model.fit_generator(train_generator,\n",
    "                              epochs=2,\n",
    "                              verbose=1,\n",
    "                              validation_data=validation_generator)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "MWZrJN4-65RC"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Text(0.5, 1.0, 'Training and validation loss')"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# PLOT LOSS AND ACCURACY\n",
    "%matplotlib inline\n",
    "\n",
    "import matplotlib.image  as mpimg\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "#-----------------------------------------------------------\n",
    "# Retrieve a list of list results on training and test data\n",
    "# sets for each training epoch\n",
    "#-----------------------------------------------------------\n",
    "acc=history.history['acc']\n",
    "val_acc=history.history['val_acc']\n",
    "loss=history.history['loss']\n",
    "val_loss=history.history['val_loss']\n",
    "\n",
    "epochs=range(len(acc)) # Get number of epochs\n",
    "\n",
    "#------------------------------------------------\n",
    "# Plot training and validation accuracy per epoch\n",
    "#------------------------------------------------\n",
    "plt.plot(epochs, acc, 'r', \"Training Accuracy\")\n",
    "plt.plot(epochs, val_acc, 'b', \"Validation Accuracy\")\n",
    "plt.title('Training and validation accuracy')\n",
    "plt.figure()\n",
    "\n",
    "#------------------------------------------------\n",
    "# Plot training and validation loss per epoch\n",
    "#------------------------------------------------\n",
    "plt.plot(epochs, loss, 'r', \"Training Loss\")\n",
    "plt.plot(epochs, val_loss, 'b', \"Validation Loss\")\n",
    "\n",
    "\n",
    "plt.title('Training and validation loss')\n",
    "\n",
    "# Desired output. Charts with training and validation metrics. No crash :)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Submission Instructions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Now click the 'Submit Assignment' button above."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# When you're done or would like to take a break, please run the two cells below to save your work and close the Notebook. This will free up resources for your fellow learners. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "<!-- Save the notebook -->\n",
    "IPython.notebook.save_checkpoint();"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "IPython.notebook.session.delete();\n",
    "window.onbeforeunload = null\n",
    "setTimeout(function() { window.close(); }, 1000);"
   ]
  }
 ],
 "metadata": {
  "accelerator": "GPU",
  "colab": {
   "collapsed_sections": [],
   "name": "Exercise 5 - Question.ipynb",
   "provenance": []
  },
  "coursera": {
   "course_slug": "convolutional-neural-networks-tensorflow",
   "graded_item_id": "laIUG",
   "launcher_item_id": "jjQWM"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
